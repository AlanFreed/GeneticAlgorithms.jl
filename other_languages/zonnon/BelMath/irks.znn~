(* ------|---------|---------|---------|---------|---------|---------|------- *)
(*       BBBB      EEEEE     L         The                                    *)
(*       B   B     E         L           BIO                                  *)
(*       BBBB      EEE       L           ENGINEERING                          *)
(*       B    B    E         L           LABORATORY                           *)
(*       BBBBB     EEEEEE    LLLLLL        @ Saginaw Valley State University  *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* Copyright 2008-2013, Alan D. Freed                                         *)
(*                                                                            *)
(* This file is part of the BEL-Math suite of .NET/Mono libraries.            *)
(*                                                                            *)
(* BEL is a free software: you can redistribute it and/or modify it under the *)
(* terms of the GNU Lesser General Public License as published by the Free    *)
(* Software Foundation, either version 3 of the License, or (at your option)  *)
(* any later version.                                                         *)
(*                                                                            *)
(* BEL is distributed in the hope that it will be useful, but WITHOUT ANY     *)
(* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  *)
(* FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for   *)
(* more details.                                                              *)
(*                                                                            *)
(* You should have received a copy of the GNU Lesser General Public License   *)
(* along with BEL.  If not, see <http://www.gnu.org/licenses/>.               *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* Provides inherent Runge-Kutta stable (IRKS) methods with property F (FSAL) *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* procedure types                                                            *)
(*   F(x : real; y : I.RealVector) : I.RealVector;  the ODEs   dy/dx = F(x,y) *)
(*   J(x : real; y : I.RealVector) : I.RealMatrix;  Jacobian   dF/dy = J(x,y) *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* object type                                                                *)
(*   Explicit         an explicit IRKS method   -  implements Bel.Entity      *)
(*     read-only variables                                                    *)
(*       functionEvaluations    number of times  f(x,y)  was calculated       *)
(*       integrationFalseStarts number of restarts caused by excessive error  *)
(*       integrationRestarts    number of restarts caused by calling Restart  *)
(*       integrationSteps       number of steps taken to solve the IVP        *)
(*       x                      the independent variable of integration       *)
(*     methods                                                                *)
(*       SetUp        prepares the integrator for use                         *)
(*         input                                                              *)
(*       Start        uses start-up method to take first step of integration  *)
(*         inputs                                                             *)
(*           f        the ODEs being integrated, i.e.,  dy/dx = f(x,y)        *)
(*           x0       the initial value  for the independent variable         *)
(*           y0       the initial values for the dependent variables - the IC *)
(*         output                                                             *)
(*           h        the initial step-size for numeric integration of f(x,y) *)
(*       Restart      called to restart integrator whenever  f(x,y) \in C^0   *)
(*         output                                                             *)
(*           h        step-size used for numeric IRKS integration of f(x,y)   *)
(*       Integrate    advances the solution by a single integration step      *)
(*         input/output                                                       *)
(*           h        stepsize used for numeric IRKS integration of f(x,y)    *)
(*                    the ODE must be continuous and differentible over the   *)
(*                    step, i.e.,  f(x,y) \in C^1  over  [x_{n-1}, x_n]       *)
(*       GetSolution  uses Taylor series to estimate solutions over history   *)
(*         input                                                              *)
(*           atX      the x value where the solution is sought                *)
(*         outputs                                                            *)
(*           y        the solution vector evaluated atX                       *)
(*           error    local truncation error over interval belonging to atX   *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* object type                                                                *)
(*   Implicit         an implicit IRKS method   -  implements Bel.Entity      *)
(*     read-only variables                                                    *)
(*       functionEvaluations    number of times  f(x,y)  was calculated       *)
(*       integrationFalseStarts number of restarts caused by excessive error  *)
(*       integrationRestarts    number of restarts caused by calling Restart  *)
(*       integrationSteps       number of steps taken to solve the IVP        *)
(*       x                      the independent variable of integration       *)
(*       jacobianEvaluations    number of times  df(x,y)/dy  was calculated   *)
(*     methods                                                                *)
(*       SetUp        prepares the integrator for use                         *)
(*         input                                                              *)
(*       Start        uses start-up method to take first step of integration  *)
(*         inputs                                                             *)
(*           f        the ODEs being integrated, i.e.,  dy/dx = f(x,y)        *)
(*           j        Jacobian of these ODEs, viz.,     df/dy = j(x,y)        *)
(*           x0       the initial value  for the independent variable         *)
(*           y0       the initial values for the dependent variables - the IC *)
(*         output                                                             *)
(*           h        the initial step-size for numeric integration of f(x,y) *)
(*       Restart      called to restart integrator whenever  f(x,y) \in C^0   *)
(*         output                                                             *)
(*           h        step-size used for numeric IRKS integration of f(x,y)   *)
(*       Integrate    advances the solution by a single integration step      *)
(*         input/output                                                       *)
(*           h        stepsize used for numeric IRKS integration of f(x,y)    *)
(*                    the ODE must be continuous and differentible over the   *)
(*                    step, i.e.,  f(x,y) \in C^1  over  [x_{n-1}, x_n]       *)
(*       GetSolution  uses Taylor series to estimate solutions over history   *)
(*         input                                                              *)
(*           atX      the x value where the solution is sought                *)
(*         outputs                                                            *)
(*           y        the solution vector evaluated atX                       *)
(*           error    local truncation error over interval belonging to atX   *)
(*     methods exported for external use by Newton's method for solving roots *)
(*       NewtonF      an instance of procedure type BelMath.Roots.F           *)
(*       NewtonJ      an instance of procedure type BelMath.Roots.J           *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(*   Exported procedures for external use by Newton's method for root solving *)
(*     StartUp                                                                *)
(*     NewtonFStartUp                                                         *)
(*     NewtonJStartUp                                                         *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)
(* References: Gustafsson, K.; Lundh, M.; and Soderlind; G.: "A PI Stepsize   *)
(*                Control for the Numerical Solution of Ordinary Differential *)
(*                Equations," BIT, 28 (1988), 270-287.                        *)
(*             Butcher, J.C., "Numerical Methods for Ordinary Differential    *)
(*                Equations", second edition, Wiley, Chirchester, 2008.       *)
(*             Freed, A.D., "Soft Solids: A primer to the theoretical         *)
(*                mechanics of materials," Birkhauser, Boston, in press.      *)
(* ------|---------|---------|---------|---------|---------|---------|------- *)

module {public} BelMath.Irks;

   import
      System.IO.BinaryReader as BinaryReader,
      System.IO.BinaryWriter as BinaryWriter,
      Bel.Entity             as Entity,
      Bel.Object             as Object,
      Bel.Keys               as Keys,
      Bel.List               as List,
      Bel.Log                as L,
      Bel.Types              as T,
      Bel.Math               as Fn,
      BelMath.Interpolations as I,
      BelMath.Roots          as R;

   var {private}
      (* global variables holding the integrators' parameters *)
      aE, aI, aS, bE, bI, bS, uE, uI, uS, vE, vI, vS : I.RealMatrix;
      cE, cI, cS, phiE, phiI                         : I.RealVector;
      phi0E, phi0I                                   : real;
      pE, pI, pS, rE, rI, rS, sE, sI, sS, s4J        : integer;
      (* global variables required by the start-up integrator *)
      fStart          : F;
      fnEval, jacEval : integer;
      hStart, xStart  : real;
      rhsStart        : I.RealVector;


   type {public}
      F = procedure (real; I.RealVector) : I.RealVector;    (* dy/dx = F(x,y) *)
      J = procedure (real; I.RealVector) : I.RealMatrix;    (* dF/dy = J(x,y) *)


   type {public, ref} Explicit = object implements Entity

      var {private}
         history  : History;
         nEq, sXn : integer;
         ode      : F;
         stepSize : StepSize;
         yIn      : I.RealVector;

      var {public, immutable}
         functionEvaluations,            (* # of calls to:  dy/dx = F(x,y)    *)
         integrationFalseStarts,         (* # of restarts caused by error     *)
         integrationRestarts,            (* # of restarts caused by Restart   *)
         integrationSteps : integer;     (* # of successful integration steps *)
         x                : real;        (* value of the independent variable *)

      procedure {public} Initialize
         implements Entity.Initialize;
      begin
         functionEvaluations    := 0;
         integrationFalseStarts := 0;
         integrationRestarts    := 0;
         integrationSteps       := 0;
         history  := new History;
         stepSize := new StepSize;
         nEq := 0;
         ode := nil;
         sXn := 0;
         x   := 0.0;
         yIn := nil
      end Initialize;

      procedure {public} Nullify
         implements Entity.Nullify;
      begin
         Initialize;
         history  := nil;
         stepSize := nil
      end Nullify;

      (* Called to start an integration.  There is no error assessment on     *)
      (* this integration step, so choose the step-size 'h' prudently.        *)
      procedure {public} Start (
               f  : F;              (* the ordinary differential equations    *)
               x0 : real;           (* initial value for independent variable *)
               y0 : I.RealVector;   (* initial value for  dependent  variable *)
               var h : real);       (* initial stepsize for IRKS integration  *)
         var
            jEval : integer;
      begin
         Initialize;
         if f # nil then
            ode := f
         else
            L.Message("The ODEs to be solved, i.e., f, were not defined.");
            L.ErrorMessage(403,20, "BelMath.Irks.Explicit.Start")
         end;
         if y0 # nil then
            nEq := len(y0);
            sXn := sE * nEq
         else
            L.Message("No dependent variables were assigned, i.e., y0 = ?.");
            L.ErrorMessage(216,20, "BelMath.Irks.Explicit.Start")
         end;
         (* insert the initial condion into the integration history *)
         x := x0;
         yIn := new I.RealVector(sXn);
         yIn[0..nEq-1] := y0[0..nEq-1];
         history.Insert(0.0, x, yIn, false);
         (* insert solution after first step of integration into the history *)
         jEval := 0;
         StartIntegration(f, x0, y0, h, x, yIn, functionEvaluations, jEval);
         inc(integrationSteps);
         history.Insert(0.0, x, yIn, false)
      end Start;

      (* Restarting becomes necessary at any point along the history where a  *)
      (* function is not differentiable, in an analytic sense.  The function  *)
      (* being integrated must otherwise be continuous.  'h' is returned.     *)
      procedure {public} Restart (var h : real);
         var
            fEval, 
            jEval  : integer;
            xBegin : real;
            yBegin : I.RealVector;
      begin
         xBegin := x;
         yBegin := new I.RealVector(nEq);
         yBegin[0..nEq-1] := yIn[0..nEq-1];
         StartIntegration(ode, xBegin, yBegin, h, x, yIn, fEval, jEval);
         inc(functionEvaluations, fEval);
         inc(integrationRestarts);
         inc(integrationSteps);
         history.Insert(0.0, x, yIn, true)
      end Restart;
      
      (* Each call to Integrate performs a single step of integration.        *)
      (* The step size is dynamically adjusted to optimize performance.       *)
      
      procedure {public} Integrate (var h : real);
         var
            eNorm, 
            error, hIn, 
            scale, xx, 
            yMag        : real;
            eV, ff, hF, 
            yDy, yS     : I.RealVector;
            i, j, k     : integer;
            redoStep    : boolean;
      begin
         hIn := h;
         eV  := new I.RealVector(nEq);
         ff  := new I.RealVector(nEq);
         hF  := new I.RealVector(sXn);
         yDy := new I.RealVector(sXn);
         yS  := new I.RealVector(nEq);
         (* scale yIn back into Nordsieck form: *)
         (* yIn = {y, h y', h^2 y'', h^3 y'''}  *)
         scale := 1.0;
         for i := 1 to rE-1 do
            scale := scale * h;
            for j := 0 to nEq-1 do
               yIn[i*nEq+j] := scale * yIn[i*nEq+j]
            end
         end;
         (* solve first set of equations: Y = A.hF + U.y[n-1] *)
         for i := 0 to sE-1 do
            for j := 0 to nEq-1 do
               yS[j] := 0.0
            end;
            for k := 0 to rE-1 do
               for j := 0 to nEq-1 do
                  yS[j] := yS[j] + uE[i,k] * yIn[j+k*nEq]
               end
            end;
            for k := 0 to i-1 do
               for j := 0 to nEq-1 do
                  yS[j] := yS[j] + aE[i,k] * hF[j+k*nEq]
               end
            end;
            (* unique part of algorithm for explicit IRKS methods *)
            inc(functionEvaluations);
            xx := x + cE[i] * h;
            ff := ode(xx, yS);
            for j := 0 to nEq-1 do
               hF[i*nEq+j] := h * ff[j]
            end
         end;
         (* solve second set of equations:  y[n] = B.hF + V.y[n-1] *)
         for i := 0 to rE-1 do
            for j := 0 to nEq-1 do
               yS[j] := 0.0
            end;
            for k := 0 to rE-1 do
               for j := 0 to nEq-1 do
                  yS[j] := yS[j] + vE[i,k] * yIn[j+k*nEq]
               end
            end;
            for k := 0 to sE-1 do
               for j := 0 to nEq-1 do
                  yS[j] := yS[j] + bE[i,k] * hF[j+k*nEq]
               end
            end;
            for j := 0 to nEq-1 do
               yDy[i*nEq+j] := yS[j]
            end
         end;
         (* compute error estimate *)
         for j := 0 to nEq-1 do
            eV[j] := phi0E * yIn[nEq+j];
            yS[j] := yIn[j]
         end;
         for i := 0 to sE-1 do
            for j := 0 to nEq-1 do
               eV[j] := eV[j] - phiE[i] * hF[i*nEq+j]
            end
         end;
         eNorm := Fn.Sqrt(eV +* eV);
         yMag  := Fn.Max(1.0, Fn.Sqrt(yS +* yS));
         error := eNorm / yMag;
         (* determine the next step size and prepare integrator for next step *)
         stepSize.Controller(error, h, redoStep);
         if redoStep then
            inc(integrationFalseStarts);
            (* remove Nordsieck scaling from the input solution vector *)
            (* put yIn into Taylor series form: {y, y', y'', y'''}     *)
            scale := 1.0;
            for i := 1 to rE-1 do
               scale := scale / hIn;
               for j := 0 to nEq-1 do
                 yIn[i*nEq+j] := scale * yIn[i*nEq+j]
               end
            end;
            Integrate(h)
         else
            inc(integrationSteps);
            x := x + hIn;
            (* remove Nordsieck scaling from the output solution vector *)
            (* put yIn into Taylor series form: {y, y', y'', y'''}      *)
            for j := 0 to nEq-1 do
               yIn[j] := yDy[j]
            end;
            scale := 1.0;
            for i := 1 to rE-1 do
               scale := scale / hIn;
               for j := 0 to nEq-1 do
                 yIn[i*nEq+j] := scale * yDy[i*nEq+j]
               end
            end;
            history.Insert(error, x, yIn, false)
         end
      end Integrate;
      
      procedure {public} GetSolution (atX       : real; 
                                      var y     : I.RealVector;
                                      var error : real);
      begin
         history.GetSolution(atX, y, error)
      end GetSolution;

   begin
      Initialize
   end Explicit;
   

   type {public, ref} Implicit = object implements Entity
      var {private}
         hNew, xNew : real;
         history    : History;
         jac        : J;
         nEq, sXn   : integer;
         ode        : F;
         stepSize   : StepSize;
         rhs, yIn   : I.RealVector;

      var {public, immutable}
         functionEvaluations,            (* # of calls to:  dy/dx = F(x,y)    *)
         integrationFalseStarts,         (* # of restarts caused by error     *)
         integrationRestarts,            (* # of restarts caused by Restart   *)
         integrationSteps,               (* # of successful integration steps *)
         jacobianEvaluations : integer;  (* # of calls to:  dF/dy = J(x,y)    *)
         x                   : real;     (* value of the independent variable *)

      procedure {public} Initialize
         implements Entity.Initialize;
      begin
         functionEvaluations    := 0;
         integrationFalseStarts := 0;
         integrationRestarts    := 0;
         integrationSteps       := 0;
         jacobianEvaluations    := 0;
         history  := new History;
         stepSize := new StepSize;
         hNew := 0.0;
         jac  := nil;
         nEq  := 0;
         ode  := nil;
         rhs  := nil;
         sXn  := 0;
         x    := 0.0;
         xNew := 0.0;
         yIn  := nil
      end Initialize;

      procedure {public} Nullify
         implements Entity.Nullify;
      begin
         Initialize;
         history  := nil;
         stepSize := nil
      end Nullify;

      (* Called to start an integration.  There is no error assessment on     *)
      (* this integration step, so choose the step-size 'h' prudently.        *)
      procedure {public} Start (
               f  : F;              (* the ordinary differential equations    *)
               j  : J;              (* the Jacobian for the system of ODEs    *)
               x0 : real;           (* initial value for independent variable *)
               y0 : I.RealVector;   (* initial value for  dependent  varialbe *)
               var h : real);       (* initial stepsize for IRKS integration  *)
      begin
         Initialize;
         if f # nil then
            ode := f
         else
            L.Message("The ODEs to be solved, i.e., f, were not defined.");
            L.ErrorMessage(403,20, "BelMath.Irks.Implicit.Start")
         end;
         if j # nil then
            jac := j
         else
            L.Message("The Jacobian for the ODEs, i.e., j, was not defined.");
            L.ErrorMessage(403,415, "BelMath.Irks.Implicit.Start")
         end;
         if y0 # nil then
            nEq := len(y0);
            sXn := sE * nEq
         else
            L.Message("No dependent variables were assigned, i.e., y0 = ?.");
            L.ErrorMessage(216,20, "BelMath.Irks.Explicit.Start")
         end;
         (* insert the initial condition into the integration history *)
         x := x0;
         yIn := new I.RealVector(sXn);
         yIn[0..nEq-1] := y0[0..nEq-1];
         history.Insert(0.0, x, yIn, false);
         (* insert solution after first step of integration into the history *)
         StartIntegration(f, x0, y0, h, x, yIn, 
                          functionEvaluations, jacobianEvaluations);
         inc(integrationSteps);
         history.Insert(0.0, x, yIn, false);
         rhs := new I.RealVector(nEq)
      end Start;

      (* Restarting becomes necessary at any point along the history where a  *)
      (* function is not differentiable, in an analytic sense.  The function  *)
      (* being integrated must otherwise be continuous. 'h' is returned.      *)
      procedure {public} Restart (var h : real);
         var
            fEval, 
            jEval  : integer;
            xBegin : real;
            yBegin : I.RealVector;
      begin
         xBegin := x;
         yBegin := new I.RealVector(nEq);
         yBegin[0..nEq-1] := yIn[0..nEq-1];
         StartIntegration(ode, xBegin, yBegin, h, x, yIn, fEval, jEval);
         inc(functionEvaluations, fEval);
         inc(jacobianEvaluations, jEval);
         inc(integrationRestarts);
         inc(integrationSteps);
         history.Insert(0.0, x, yIn, true)
      end Restart;
      
      (* Each call to Integrate performs a single step of integration.        *)
      (* The step size is dynamically adjusted to optimize performance.       *)

      procedure {public} Integrate (var h : real);
         var
            eNorm, 
            error, hIn,
            scale,
            yMag        : real;
            eV, hf, hF, 
            yDy, yS     : I.RealVector;
            i, j, k     : integer;
            redoStep    : boolean;
      begin
         hNew := h;
         hIn  := h;
         eV   := new I.RealVector(nEq);
         hf   := new I.RealVector(nEq);
         hF   := new I.RealVector(sXn);
         yDy  := new I.RealVector(sXn);
         yS   := new I.RealVector(nEq);
         (* scale yIn back into Nordsieck form: *)
         (* yIn = {y, h y', h^2 y'', h^3 y'''}  *)
         scale := 1.0;
         for i := 1 to rI-1 do
            scale := scale * h;
            for j := 0 to nEq-1 do
               yIn[i*nEq+j] := scale * yIn[i*nEq+j]
            end
         end;
         (* solve first set of equations: Y = A.hF + U.y[n-1] *)
         for i := 0 to sI-1 do
            for j := 0 to nEq-1 do
               yS[j] := 0.0
            end;
            for k := 0 to rI-1 do
               for j := 0 to nEq-1 do
                  yS[j] := yS[j] + uI[i,k] * yIn[j+k*nEq]
               end
            end;
            for k := 0 to i-1 do
               for j := 0 to nEq-1 do
                  yS[j] := yS[j] + aI[i,k] * hF[j+k*nEq]
               end
            end;
            (* unique part of algorithm for implicit IRKS methods        *)
            (* assign guessed value needed to start Newton's root solver *)
            if i = 0 then
               (* these are property F methods, i.e., FSAL, so *)
               for j := 0 to nEq-1 do
                  hf[j] := yIn[nEq+j]
               end
            else
               (* use prior stage value to estimate  h*f(x,y) *)
               for j := 0 to nEq-1 do
                  hf[j] := hF[(i-1)*nEq+j]
               end
            end;
            (* send rhs as yS, returns estimate for stage  yS *)
            xNew := x + cI[i] * h;
            s4J  := i;                (* assign stage for use in F and J *)
            SolveRoot(yS, hf);
            for j := 0 to nEq-1 do
               hF[i*nEq+j] := hf[j]
            end
         end;
         (* solve second set of equations:  y[n] = B.hF + V.y[n-1] *)
         for i := 0 to rI-1 do
            for j := 0 to nEq-1 do
               yS[j] := 0.0
            end;
            for k := 0 to rI-1 do
               for j := 0 to nEq-1 do
                  yS[j] := yS[j] + vI[i,k] * yIn[j+k*nEq]
               end
            end;
            for k := 0 to sI-1 do
               for j := 0 to nEq-1 do
                  yS[j] := yS[j] + bI[i,k] * hF[j+k*nEq]
               end
            end;
            for j := 0 to nEq-1 do
               yDy[i*nEq+j] := yS[j]
            end
         end;
         (* compute error estimate *)
         for j := 0 to nEq-1 do
            eV[j] := phi0I * yIn[nEq+j];
            yS[j] := yIn[j]
         end;
         for i := 0 to sI-1 do
            for j := 0 to nEq-1 do
               eV[j] := eV[j] - phiI[i] * hF[i*nEq+j]
            end
         end;
         eNorm := Fn.Sqrt(eV +* eV);
         yMag  := Fn.Max(1.0, Fn.Sqrt(yS +* yS));
         error := eNorm / yMag;
         (* determine the next step size and prepare integrator for next step *)
         stepSize.Controller(error, h, redoStep);
         if redoStep then
            inc(integrationFalseStarts);
            (* remove Nordsieck scaling from the input solution vector *)
            (* put yIn into Taylor series form: {y, y', y'', y'''}     *)
            scale := 1.0;
            for i := 1 to rI-1 do
               scale := scale / hIn;
               for j := 0 to nEq-1 do
                 yIn[i*nEq+j] := scale * yIn[i*nEq+j]
               end
            end;
            Integrate(h)
         else
            inc(integrationSteps);
            x := x + hIn;
            (* remove Nordsieck scaling from the output solution vector *)
            (* put yIn into Taylor series form: {y, y', y'', y'''}      *)
            for j := 0 to nEq-1 do
               yIn[j] := yDy[j]
            end;
            scale := 1.0;
            for i := 1 to rI-1 do
               scale := scale / hIn;
               for j := 0 to nEq-1 do
                 yIn[i*nEq+j] := scale * yDy[i*nEq+j]
               end
            end;
            history.Insert(error, x, yIn, false)
         end
      end Integrate;

      procedure {public} GetSolution (atX       : real; 
                                      var y     : I.RealVector;
                                      var error : real);
      begin
         history.GetSolution(atX, y, error)
      end GetSolution;
      
      (* Function that Newton's root finder solves *)
      procedure {public} NewtonF (y : I.RealVector) : I.RealVector;
         var
            fn, fF, fY, hF, yS : I.RealVector;
            j                  : integer;
      begin
         (* simultaneously solve the the system of equations *)
         (*    yS - lambda*hF - rhs = 0     lambda = A[k,k]  *)
         (*    hF - h*f(x+c*h, yS)  = 0                      *)
         (* for yS and hF using Newton's method, where       *)
         (*    yS   is sent in the first  half of vector y   *)
         (*    hF   is sent in the second half of vector y   *)
         inc(functionEvaluations);
         fF := new I.RealVector(nEq);
         fn := new I.RealVector(2*nEq);
         fY := new I.RealVector(nEq);
         hF := new I.RealVector(nEq);
         yS := new I.RealVector(nEq);
         yS[0..nEq-1] := y[0..nEq-1];      (* get the stage values  *)
         hF[0..nEq-1] := y[nEq..2*nEq-1];  (* get stage derivatives *)
         for j := 0 to nEq-1 do
            fY[j] := yS[j] - aI[s4J,s4J] * hF[j] - rhs[j]
         end;
         fF := ode(xNew, yS);
         fF := hF - hNew * fF;
         fn[0..nEq-1]     := fY[0..nEq-1];
         fn[nEq..2*nEq-1] := fF[0..nEq-1];
         return fn
      end NewtonF;

      (* Jacobian of NewtonF for Newton's root finder *)
      procedure {public} NewtonJ (y : I.RealVector) : I.RealMatrix;
         var
            hJ, jacobian : I.RealMatrix;
            i,  j        : integer;
            yS           : I.RealVector;
      begin
         inc(jacobianEvaluations);
         hJ       := new I.RealMatrix(nEq,nEq);
         jacobian := new I.RealMatrix(2*nEq,2*nEq);
         yS       := new I.RealVector(nEq);
         (* construct the Jacobian *)
         for i := 0 to 2*nEq-1 do
            for j := 0 to 2*nEq-1 do
               jacobian[i,j] := 0.0
            end;
            jacobian[i,i] := 1.0
         end;
         for i := 0 to nEq-1 do
            jacobian[i,nEq+i] := -aI[s4J,s4J];
            yS[i]             := y[i]
         end;
         hJ := jac(xNew, yS);
         hJ := -hNew * hJ;
         for i := 0 to nEq-1 do
            for j := 0 to nEq-1 do
               jacobian[nEq+i,j] := hJ[i,j]
            end
         end;
         return jacobian
      end NewtonJ;

      procedure {private} SolveRoot (var y, hF : I.RealVector);
         var
            vec : I.RealVector;
      begin
         vec := new I.RealVector(2*nEq);
         (* assign global variable used by NewtonFStartUp *)
         rhs := y;
         (* guess an initial vector whose root is being sought *)
         vec[0..nEq-1]     := y[0..nEq-1];
         vec[nEq..2*nEq-1] := hF[0..nEq-1];
         (* solve for the root *)
         R.Newton(NewtonF, NewtonJ, vec);
         (* return the separate values *)
         y [0..nEq-1] := vec[0..nEq-1];
         hF[0..nEq-1] := vec[nEq..2*nEq-1]
      end SolveRoot;

   begin
      Initialize
   end Implicit;

   
      (* Procedures StartUp, NewtonFStartUp and NewtonJStartUp are all    *)
      (* called externally by BelMath.Roots.Newton to solve an equation.  *)

      (* Computes a reasonable initial step-size to begin integration.    *)
      procedure {private} HStartUp (x0 : real; y0 : I.RealVector) : real;
         var 
            h, h0, f0mag, f1mag, 
               x1, y0mag, y1mag  : real;
            f0, f1, y1           : I.RealVector;
      begin
         y0mag := Fn.Sqrt(y0 +* y0);
         y0mag := Fn.Max(T.Epsilon, y0mag);
         f0    := fStart(x0, y0);
         f0mag := Fn.Sqrt(f0 +* f0);
         f0mag := Fn.Max(T.Epsilon, f0mag);
         h0    := y0mag / f0mag;
         h0    := Fn.Max(T.Epsilon, h0);
         h0    := Fn.Min(0.001, h0);
         x1    := x0 + h0;
         y1    := y0 + h0 * f0;
         f1    := fStart(x1, y1);
         y1    := y0 + 0.5 * h0 * (f0 + f1);
         y1mag := Fn.Sqrt(y1 +* y1);
         y1mag := Fn.Max(T.Epsilon, y1mag);
         f1    := fStart(x1, y1);
         f1mag := Fn.Sqrt(f1 +* f1);
         f1mag := Fn.Max(T.Epsilon, f1mag);
         h     := 2.0 * abs((y1mag - y0mag) / (f1mag + f0mag));
         h     := h / 10.0;   (* a factor of safety *)
         h     := Fn.Max(T.Epsilon, h);
         h     := Fn.Min(0.001, h);
         return h
      end HStartUp;
      
      (* Used to compute numerical Jacobian for the start-up integrator.  *)
      procedure {public} StartUp (y : I.RealVector) : I.RealVector;
         var
            f : I.RealVector;
      begin
         inc(fnEval);
         f := new I.RealVector(len(y));
         f := fStart(xStart, y);
         return f
      end StartUp;

      (* Function that Newton's root finder solves for start-up integrator *)
      procedure {public} NewtonFStartUp (y : I.RealVector) : I.RealVector;
         var
            dim, nEq           : integer;
            fn, fF, fY, hF, yS : I.RealVector;
      begin
         (* simultaneously solve the the system of equations *)
         (*    yS - lambda*hF - rhs = 0     lambda = A[i,i]  *)
         (*    hF - h*f(x+c*h, yS)  = 0                      *)
         (* for yS and hF using Newton's method, where       *)
         (*    yS   is sent in the first  half of vector y   *)
         (*    hF   is sent in the second half of vector y   *)
         inc(fnEval);
         dim := len(y);
         nEq := dim div 2;
         fF  := new I.RealVector(nEq);
         fn  := new I.RealVector(dim);
         fY  := new I.RealVector(nEq);
         hF  := new I.RealVector(nEq);
         yS  := new I.RealVector(nEq);
         yS[0..nEq-1] := y[0..nEq-1];       (* get the stage values  *)
         hF[0..nEq-1] := y[nEq..2*nEq-1];   (* get stage derivatives *)
         fY := yS - aS[s4J,s4J] * hF - rhsStart;
         fF := fStart(xStart, yS);
         fF := hF - hStart * fF;
         fn[0..nEq-1]     := fY[0..nEq-1];
         fn[nEq..2*nEq-1] := fF[0..nEq-1];
         return fn
      end NewtonFStartUp;
 
      (* Jacobian for Newton's root finder for the start-up integrator *)
      procedure {public} NewtonJStartUp (y : I.RealVector) : I.RealMatrix;
         var
            dim, nEq, i, j : integer;
            hJ, jac        : I.RealMatrix;
            yS             : I.RealVector;
      begin
         inc(jacEval);
         dim := len(y);
         nEq := dim div 2;
         hJ  := new I.RealMatrix(nEq,nEq);
         jac := new I.RealMatrix(dim,dim);
         yS  := new I.RealVector(nEq);
         (* construct the Jacobian *)
         for i := 0 to dim-1 do
            for j := 0 to dim-1 do
               jac[i,j] := 0.0
            end;
            jac[i,i] := 1.0
         end;
         for i := 0 to nEq-1 do
            jac[i,nEq+i] := -aS[s4J,s4J];
            yS[i]        := y[i]
         end;
         hJ := -hStart * R.NumericalJacobian(StartUp, yS);
         for i := 0 to nEq-1 do
            for j := 0 to nEq-1 do
               jac[nEq+i,j] := hJ[i,j]
            end
         end;
         return jac
      end NewtonJStartUp;
      
      procedure {private} ImplicitStartUp (var y, hF : I.RealVector);
         var
            dim, i, nEq : integer;
            vec         : I.RealVector;
      begin
         nEq := len(y);
         dim := 2 * nEq;
         (* assign global variable used by NewtonFStartUp *)
         rhsStart := new I.RealVector(nEq);
         rhsStart := y;
         (* guess an initial vector whose root is being sought *)
         vec := new I.RealVector(dim);
         for i := 0 to nEq-1 do
            vec[i]     := y[i];
            vec[nEq+i] := hF[i]
         end;
         (* solve for the root *)
         R.Newton(NewtonFStartUp, NewtonJStartUp, vec);
         (* return the separate values *)
         for i := 0 to nEq-1 do
            y[i]  := vec[i];
            hF[i] := vec[nEq+i]
         end
      end ImplicitStartUp;

   (* Call this procedure to start or restart an integration to get the *)
   (* array yDy that you need to supply to either Explicit.Integrate or *)
   (* to Implicit.Integrate to continue with your integration.  This is *)
   (* actually called internally by Explicit.Start and Implicit.Start.  *)

   procedure {private} StartIntegration (
         f        : F;              (* the right-hand side of  dy/dx = f(x,y) *)
         x0       : real;           (* initial value for independent variable *)
         y0       : I.RealVector;   (* initial values for dependent variables *)
         var h    : real;           (* next step size to use for integration  *)
         var x    : real;           (* x := x0 + h                            *)
         var yDy  : I.RealVector;   (* {y, y', y'', y'''} @ x0 + h            *)
         var nFn  : integer;        (* number of function evaluations made    *)
         var nJac : integer);       (* number of Jacobian evaluations made    *)
      var
         hf, hF, yS             : I.RealVector;
         i, j, k, nEq, rXn, sXn : integer;
         scale                  : real;
   begin {locked}
      (* store for use by procedures StartUp and NewtonFStartUp *)
      fStart  := f;
      fnEval  := 0;
      h       := HStartUp(x0, y0);
      hStart  := h;
      jacEval := 0;
      (* initialize the method *)
      nEq := len(y0);
      rXn := rS * nEq;
      sXn := sS * nEq;
      yS  := new I.RealVector(nEq);
      hf  := new I.RealVector(nEq);
      hF  := new I.RealVector(sXn);
      yDy := new I.RealVector(rXn);
      (* solve first set of equations: Y = A.hF + U.y[n-1] *)
      for i := 0 to sS-1 do
         xStart := x0 + cS[i] * h;
         for j := 0 to nEq-1 do
            yS[j] := 0.0
         end;
         (* In start-up method, matrix U can only have non-zero first column *)
         for j := 0 to nEq-1 do
            yS[j] := yS[j] + uS[i,0] * y0[j]
         end;
         for k := 0 to i-1 do
            for j := 0 to nEq-1 do
               yS[j] := yS[j] + aS[i,k] * hF[j+k*nEq]
            end
         end;
         (* implicit step of the integrator *)
         inc(fnEval);
         hf  := f(xStart, yS);    (* guess *)
         hf  := h * hf;
         s4J := i;                (* assign stage for use in F and J *)
         ImplicitStartUp(yS, hf);
         for j := 0 to nEq-1 do
            hF[i*nEq+j] := hf[j]
         end
      end;
      (* solve second set of equations:  y[n] = B.hF + V.y[n-1] *)
      for i := 0 to rS-1 do
         for j := 0 to nEq-1 do
            yS[j] := 0.0
         end;
         (* In start-up method, matrix V can only have non-zero first column *)
         for j := 0 to nEq-1 do
            yS[j] := yS[j] + vS[i,0] * y0[j]
         end;
         for k := 0 to sS-1 do
            for j := 0 to nEq-1 do
               yS[j] := yS[j] + bS[i,k] * hF[j+k*nEq]
            end
         end;
         for j := 0 to nEq-1 do
            yDy[i*nEq+j] := yS[j]
         end
      end;
      (* remove Nordsieck scaling from the solution vector  *)
      (* put it into Taylor series form: {y, y', y'', y'''} *)
      scale := 1.0;
      for i := 1 to rS-1 do
         scale := scale / h;
         for j := 0 to nEq-1 do
            yDy[i*nEq+j] := scale * yDy[i*nEq+j]
         end
      end;
      x    := x0 + h;
      nFn  := fnEval;
      nJac := jacEval
   end StartIntegration;

   (* Uses a PI controller to dynamically control the stepsize of integration *)
   
   type {private, ref} StepSize = object
   
      var {private}
         maxError,
         prevError : real;

      procedure {public} Initialize;
      begin
         maxError  := 0.0001; (* integrators are 3rd-order accurate *)
         prevError := 0.0
      end Initialize;
      
      procedure {public} Controller (currentError  : real;
                                     var stepSize  : real;
                                     var redoStep  : boolean);
         var
            scaleFactor : real;
      begin
         redoStep := false;
         if currentError < 1.2*maxError then
            if prevError < 1.2*maxError then
               (* use a PI controller *)
               scaleFactor := Fn.Power(maxError/currentError, 0.15)
                            * Fn.Power(prevError/maxError, 0.1)
            else 
               (* use a P controller *)
               scaleFactor := Fn.Power(maxError/currentError, 0.25)
            end
         else
            redoStep := true;
            (* use a P controller *)
            scaleFactor := Fn.Power(maxError/currentError, 0.33)
         end;
         prevError := currentError;
         if scaleFactor > 5.0 then
            (* anti wind-up *)
            stepSize := 5.0*stepSize
         elsif scaleFactor < 0.1 then
            (* anti wind-down *)
            stepSize := 0.1*stepSize
         else
            stepSize := scaleFactor*stepSize
         end
      end Controller;
      
   begin
      Initialize
   end StepSize;

   (* Solution data from an integrator for storage in a list. *)
   
   type {private, ref} Data = object implements Object
   
      var {public}
         error,        x : real;
         taylorSeries, y : I.RealVector;
   
      procedure {public} Initialize
         implements Object.Initialize;
      begin
         error        := 0.0;
         taylorSeries := nil;
         x            := 0.0;
         y            := nil
      end Initialize;
      
      procedure {public} Nullify
         implements Object.Nullify;
      begin
         Initialize
      end Nullify;
      
      procedure {public} Clone () : object{Object}
         implements Object.Clone;
         var
            clone : Object;
            datum : Data;
      begin
         datum := new Data;
         clone := Object(datum);
         return clone
      end Clone;
      
      procedure {public} Load (br : BinaryReader) 
         implements Object.Load;
         var
            storeSeries : boolean;
      begin 
         error       := T.LoadReal(br);
         storeSeries := T.LoadBoolean(br);
         if storeSeries then
            taylorSeries := T.LoadRealVector(br)
         else
            taylorSeries := nil
         end;
         x := T.LoadReal(br);
         y := T.LoadRealVector(br)
      end Load;
      
      procedure {public} Store (bw : BinaryWriter)
         implements Object.Store;
      begin
         T.StoreReal(bw, error);
         if taylorSeries = nil then
            T.StoreBoolean(bw, false)
         else
            T.StoreBoolean(bw, true);
            T.StoreRealVector(bw, taylorSeries)
         end;
         T.StoreReal(bw, x);
         T.StoreRealVector(bw, y)
      end Store;
      
   begin
      Initialize
   end Data;

   (* A list that stores the history of integration data *)
   
   type {private, ref} History = object implements Object
   
      var
         list : List;
         step : integer;
   
      procedure {public} Initialize
         implements Object.Initialize;
         var
            data : Data;
      begin
         data := new Data;
         list := new List;
         list.Configure(data.Clone());
         step := -1
      end Initialize;
      
      procedure {public} Nullify
         implements Object.Nullify;
      begin
         list.Nullify;
         step := 0
      end Nullify;
      
      procedure {public} Clone () : object{Object}
         implements Object.Clone;
         var
            clone   : object{Object};
            history : History;
      begin
         history := new History;
         clone   := Object(history);
         return clone
      end Clone;
      
      procedure {public} Load (br : BinaryReader) 
         implements Object.Load;
      begin
         Initialize;
         list.Load(br);
         step := T.LoadInteger(br)
      end Load;
      
      procedure {public} Store (bw : BinaryWriter)
         implements Object.Store;
      begin
         list.Store(bw);
         T.StoreInteger(bw, step)
      end Store;
      
      (* Assumes the integrator is a third-order method with 4 stages/steps.  *)
      procedure {public} Insert (
                         error,                       (* truncation error     *)
                         x            : real;         (* independent variable *)
                         taylorSeries : I.RealVector; (* {y, y', y'', y'''}   *)
                         restart      : boolean);     (* only insert {y} if T *)
         var
            data    : Data;
            i,
            length  : integer;
            key     : Keys.Key;
            success : boolean;
            obj     : object{Object};
      begin
         data := new Data;
         if restart then
            (* Remove derivative terms in Taylor series - soln discontinuous. *)
            key  := step;
            list.Find(key, success);
            obj  := list.GetData();
            data := Data(obj);
            data.taylorSeries := nil;
            obj  := Object(data);
            list.Update(obj, key, success);
            data.Initialize;
            key.Initialize
         end;
         inc(step);
         data.error := error;
         data.x := x;
         length := len(taylorSeries) div 4;
         data.y := new I.RealVector(length);
         data.y[0..length-1] := taylorSeries[0..length-1];
         if step > 0 then
            data.taylorSeries := new I.RealVector(3*length);
            data.taylorSeries[0..3*length-1] := taylorSeries[length..4*length-1]
         else
            data.taylorSeries := nil
         end;
         key := step;
         obj := Object(data);
         list.Insert(obj, key, success);
         if ~success then
            L.Message("Failed to insert data at step " + 
                      T.IntegerToString(step) + " into the history list.");
            L.WarningMessage(520,90,"BelMath.Irks.History.Insert")
         end
      end Insert;
      
      (* Assumes the integrator is a third-order method. *)
      procedure {private} Interpolate (atX   : real;
                                       dataL : Data;
                                       dataR : Data;
                                       var y : I.RealVector);
         var
            h,  h1, 
            h2, h3,
            lfWgt,
            rtWgt     : real;
            i, length : integer;
            yL, yR    : I.RealVector;
      begin
         length := len(dataL.y);
         y      := new I.RealVector(length);
         h      := dataR.x - dataL.x;
         lfWgt  := (dataR.x - atX)/h;
         rtWgt  := (atX - dataL.x)/h;
         if dataL.taylorSeries = nil then
            if dataR.taylorSeries = nil then
               (* linear interpolation over the interval *)
               for i := 0 to length-1 do
                  y[i] := lfWgt*dataL.y[i] + rtWgt*dataR.y[i]
               end
            else
               (* Taylor series expanded from the right side of the interval *)
               h1 := atX - dataR.x; (* negative valued *)
               h2 := h1*h1/2.0;
               h3 := h1*h2/3.0;
               for i := 0 to length-1 do
                  y[i] := dataR.y[i] 
                        + h1*dataR.taylorSeries[i] 
                        + h2*dataR.taylorSeries[length+i] 
                        + h3*dataR.taylorSeries[2*length+i]
               end
            end
         elsif dataR.taylorSeries = nil then
            (* Taylor series expanded from the left side of the interval *)
            h1 := atX - dataL.x; (* positive valued *)
            h2 := h1*h1/2.0;
            h3 := h1*h2/3.0;
            for i := 0 to length-1 do
               y[i] := dataL.y[i] 
                     + h1*dataL.taylorSeries[i] 
                     + h2*dataL.taylorSeries[length+i] 
                     + h3*dataL.taylorSeries[2*length+i]
            end
         else
            yL := new I.RealVector(length);
            yR := new I.RealVector(length);
            (* Taylor series expanded from the left side of the interval *)
            h1 := atX - dataL.x; (* positive valued *)
            h2 := h1*h1/2.0;
            h3 := h1*h2/3.0;
            for i := 0 to length-1 do 
               yL[i] := dataL.y[i] 
                      + h1*dataL.taylorSeries[i] 
                      + h2*dataL.taylorSeries[length+i] 
                      + h3*dataL.taylorSeries[2*length+i]
            end;
            (* Taylor series expanded from the right side of the interval *)
            h1 := atX - dataR.x; (* negative valued *)
            h2 := h1*h1/2.0;
            h3 := h1*h2/3.0;
            for i := 0 to length-1 do
               yR[i] := dataR.y[i] 
                      + h1*dataR.taylorSeries[i] 
                      + h2*dataR.taylorSeries[length+i] 
                      + h3*dataR.taylorSeries[2*length+i]
            end;
            (* weighted average of these two Taylor series estimates *)
            for i := 0 to length-1 do
               y[i] := lfWgt*yL[i] + rtWgt*yR[i]
            end
         end
      end Interpolate;

      procedure {public} GetSolution (atX       : real; 
                                      var y     : I.RealVector;
                                      var error : real);
         var
            data,
            dataL,
            dataR  : Data;
            moved  : boolean;
            obj    : object{Object};
      begin
         (* find the interval where interpolation will take place *)
         obj  := list.GetData();
         data := Data(obj);
         while atX < data.x do
            list.Previous(moved);
            if ~moved then
               L.Message("The 'x' for interpolation was out of range.");
               L.ErrorMessage(81,20,"BelMath.Irks.History.GetSolution")
            end;
            obj  := list.GetData();
            data := Data(obj)
         end;
         while atX > data.x do
            list.Next(moved);
            if ~moved then
               L.Message("The 'x' for interpolation was out of range.");
               L.ErrorMessage(81,20,"BelMath.Irks.History.GetSolution") 
            end;
            obj  := list.GetData();
            data := Data(obj)
         end;
         (* interpolate to get the value for the solution vector *)
         if data.x = atX then
            y     := data.y;
            error := data.error
         elsif data.x > atX then
            dataR := data;
            list.Previous(moved);
            obj   := list.GetData();
            dataL := Data(obj);
            Interpolate(atX, dataL, dataR, y);
            error := dataR.error
         else
            dataL := data;
            list.Next(moved);
            obj   := list.GetData();
            dataR := Data(obj);
            Interpolate(atX, dataL, dataR, y);
            error := dataR.error
         end
      end GetSolution;
      
   begin     
      Initialize
   end History;
   
begin
   (* Used to pass which stage one is solving at to the appropriate Jacobian  *)
   s4J := 0;
   (* Notations E -> explicit, I -> implicit, and S -> start-up integrator    *)
   (* Methods are taken from "Atlas of general linear methods with inherent   *)
   (* Runge-Kutta stability", http://www.math.auckland.ac.nz/~hpod/atlas      *)
   (*    the explicit method is from file html/e3a.html of the atlas          *)
   (*       stage errors: {0.0100271, -0.0259168, -0.0671131, 0.00320513}^T   *)
   (*    the implicit method is from file html/i3a.html of the atlas          *)
   (*       stage erorrs: {-0.0131524, -0.029952, 0.0381657, 0.000542057}^T   *)
   (*    the starter method came from John Butcher; it isn't published yet    *)
   (* These are the orders in accuracy of the individual methods implemented  *)
   pE := 3;
   pI := 3;
   pS := 3;
   (* These are the number of steps in the multi-step part of each method     *)
   rE := 4;
   rI := 4;
   rS := 4;
   (* These are the number of stages in the multi-stage part of each method   *)
   sE := 4;
   sI := 4;
   sS := 4;
   (* These are the quadrature points used over the interval of integration   *)
   cE := new I.RealVector(4);
   cE := [0.25, 0.5, 0.75, 1.0];
   cI := new I.RealVector(4);
   cI := [0.25, 0.5, 0.75, 1.0];
   cS := new I.RealVector(4);
   cS := [0.25, 0.5, 0.75, 1.0];
   (* these are the error estimation parameters *)
   phiE  := new I.RealVector(4);
   phi0E := 98.267807;
   phiE  := [329.071228, -397.606843, 201.071228, -34.267807];
   phiI  := new I.RealVector(4);
   phi0I := 43.700369;
   phiI  := [110.801474, -70.202212, -17.198526, 20.299631];
   (* provide the A, B, U and V matrices that define these linear methods *)
   aE := new I.RealMatrix(4,4);
   aE := [[ 0.0,       0.0,      0.0,      0.0],
          [ 0.845232,  0.0,      0.0,      0.0],
          [-0.0449691, 0.882754, 0.0,      0.0],
          [ 1.03061,   0.483638, 0.157846, 0.0]];
   aI := new I.RealMatrix(4,4);
   aI := [[0.225,     0.0,      0.0,      0.0  ],
          [0.211287,  0.225,    0.0,      0.0  ],
          [0.946338, -0.342943, 0.225,    0.0  ],
          [0.52149,  -0.662474, 0.490476, 0.225]];
   aS := new I.RealMatrix(4,4);
   aS := [[ 0.25,     0.0,       0.0,      0.0 ],
          [ 0.25,     0.25,      0.0,      0.0 ],
          [-1.25,     1.75,      0.25,     0.0 ],
          [ 5.0/12.0, 5.0/12.0, -1.0/12.0, 0.25]];
   bE := new I.RealMatrix(4,4);
   bE := [[ 1.03061,   0.483638, 0.157846,  0.0    ],
          [ 0.0,       0.0,      0.0,       1.0    ],
          [-0.712022, -0.63459, -0.0665772, 1.06962],
          [-0.707945, -0.57053, -0.210071,  0.622123]];
   bI := new I.RealMatrix(4,4);
   bI := [[ 0.52149,  -0.662474,  0.490476, 0.225   ],
          [ 0.0,       0.0,       0.0,      1.0     ],
          [-0.0423385, 0.695379, -0.784079, 1.0116  ],
          [ 0.077564,  0.246379, -0.321806, 0.274145]];
   bS := new I.RealMatrix(4,4);
   bS := [[ 5.0/12.0,   5.0/12.0, -1.0/12.0, 0.25],
          [ 0.0,        0.0,       0.0,      1.0 ],
          [ 2.9,       -6.7,       0.7,      3.1 ],
          [11.2,      -17.6,       1.6,      4.8 ]];
   uE := new I.RealMatrix(4,4);
   uE := [[1.0,  0.25,      0.0625,    0.015625],
          [1.0, -0.345232, -0.172616, -0.033481],
          [1.0, -0.087785, -0.29777,  -0.231759],
          [1.0, -0.672094, -0.235712,  0.177668]];
   uI := new I.RealMatrix(4,4);
   uI := [[1.0,  0.025,     -0.05,      -0.0265625],
          [1.0,  0.063713,  -0.0806435, -0.0833663],
          [1.0, -0.0783954,  0.0947737,  0.121956 ],
          [1.0,  0.425507,   0.216014,  -0.103603 ]];
   uS := new I.RealMatrix(4,4);
   uS := [[1.0, 0.0, 0.0, 0.0],
          [1.0, 0.0, 0.0, 0.0],
          [1.0, 0.0, 0.0, 0.0],
          [1.0, 0.0, 0.0, 0.0]];
   vE := new I.RealMatrix(4,4);
   vE := [[1.0, -0.672094, -0.235712,   0.177668],
          [0.0,  0.0,       0.0,        0.0     ],
          [0.0,  0.343573, -0.0487644,  0.512949],
          [0.0,  0.866424, -0.00463586, 0.0487644]];
   vI := new I.RealMatrix(4,4);
   vI := [[1.0,  0.425507,  0.216014, -0.103603],
          [0.0,  0.0,       0.0,       0.0     ],
          [0.0, -0.880558, -0.521284,  0.774748],
          [0.0, -0.276282, -0.350743,  0.521284]];
   vS := new I.RealMatrix(4,4);
   vS := [[1.0, 0.0, 0.0, 0.0],
          [0.0, 0.0, 0.0, 0.0],
          [0.0, 0.0, 0.0, 0.0],
          [0.0, 0.0, 0.0, 0.0]]
end Irks.
