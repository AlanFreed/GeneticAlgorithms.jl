(* *****************************************************************************
  genAlg Author         - Alan D. Freed
  genAlg License        - GNU Lesser General Public License, vs 3 or later
  genAlg Copyright      - (c) Alan D. Freed 2014
  genAlg Pascal Version - 1.3.3
--------------------------------------------------------------------------------
  Use a genetic algorithm for the purpose of parameter estimation.
--------------------------------------------------------------------------------
  This application uses three external libraries, all written by the author:
     'Arrays' provides a collection of array type and procedures to manage them
     'rng'    provides a random number generator and statistical functions.
     'GenAlg' provides a genetic algorithm for use in parameter estimation.
--------------------------------------------------------------------------------
   This is one of three parts to the template. Here is where the solver resides.
   This unit should require little if any application specific modifications.
   You will need to write a driver to call this solver, e.g., one can use the
   charting capability of Lazarus and call this solver from a charting program.
--------------------------------------------------------------------------------
   References
      Goldberg, D.E., Genetic Algorithms in Search, Optimization, and Machine
         Learning, Addison-Wesley, Boston, 1989.
      Goldberg, D.E., The Design of Innovation: Lessons learned from and for
         competent genetic algorithms.  In: Genetic algorithms and evolutionary
         computation, Vol. 7, Klewer, Boston, 2002.
      Johnson, N.L., "Systems of Frequency Curves Generated by Methods of
         Translation," Biometrika, Vol. 36 (1949), 149-176.       
***************************************************************************** *)

// global directives
{$MODE OBJFPC}      // allows objects, classes, interfaces, exception handling
{$H+}               // use ANSI strings
{$IFDEF UNIX}
  {$CALLING CDECL}  // uses the GCC calling convention  - for Unix libraries
  {$PIC ON}         // create Position Independent Code - for Unix libraries
{$ENDIF}

unit gaRelaxSolver;

interface

  uses
    {$IFDEF UNIX}{$IFDEF UseCThreads}
      cthreads,
    {$ENDIF}{$ENDIF}
    Classes, SysUtils, gaCore, gaRelaxData, gaRelaxModel;

  // Exported procedures

  procedure RunGeneticAlgorithm (reportName : String);
  // execute the genetic algorithm to fit a model to experimental data

  procedure GetEliteData (var parameters : TRVector;
                          var genome     : TSVector);
  // model parameters that fit the data with the minimum RMSE to the data

  procedure GetModelData (selectExperiment : Integer;             // 1..dimE
                          var xExperiment  : TRMatrix;            // output
                          var yExperiment  : TRMatrix;            // output
                          var xModel       : TRMatrix;            // input
                          var yModel       : TRMatrix);           // output
  // get data pairs for the experimental data and the model fits to these data
  // the experimental matrices are indexed as [variable][sample]
  // the model matrices index as [variable][node] where the node may differ 
  // from the sampling points
  
implementation

  // Procedures used to manage the genetic algorithm 'GenAlg' library.

  procedure StartGeneticAlgorithm (numericalModel      : TModel;
                                   var expControlData  : TRData;
                                   var expResponseData : TRData;
                                   var varyParameters  : TBVector;
                                   fixedParameters     : TVectorFn;
                                   var alienParameters : TRVector;
                                   var minParameters   : TRVector;
                                   var maxParameters   : TRVector;
                                   significantFigs     : Integer;
                                   var parameterNames  : TSVector;
                                   reportFileName      : String);
                                   external 'GenAlg';
  { Create a new optimization project and run it through the first generation.
    where
      numericalModel  : the model whose parameters are sought
      expControlData  : the control  values in the experimental data set
      expResponseData : the response values in the experimental data set
      varyParameters  : those parameters that the optimizer will vary
      fixedParameters : values for the fixed parameters - nil if all will vary
      alienParameters : best guess at the values of the varied parameters
      minParameters   : minimum allowed values for the varied parameters
      maxParameters   : maximum allowed values for the varied parameters
      significantFigs : significant figures sought in parameters - 2 to 7
      parameterNames  : array of strings that provide names for the parameters
      reportFileName  : name of the file for writing the report to, less .txt  }

  procedure AdvanceToNextGeneration (out converged : Boolean); external 'GenAlg';
  { Advance the genetic algorithm to its next generation.
    where
      converged : indicates if algorithm has 'theoretically' converged or not  }

  procedure StopGeneticAlgorithm; external 'GenAlg';
  { Terminate the genetic algorithm and close the associated GA report file.   }

  procedure EliteCreatureData (out fitness    : Real;
                               var parameters : TRVector;
                               var genome     : TSVector); external 'GenAlg';
  { Retreive data about the elite creature from the current generation.
    where
      fitness    : value of the elite creature's fitness or quality parameter
                               1  E     RANGE(expY_e)
                   fitness   = - SUM --------------------
                               E e=1 RSME(expY_e, modY_e)
                   E     is  the number of experiments being fit against
                   expY  are the response data measured in experiments
                   modY  are the response data preducted by the model
      parameters : the model parameters that associate with with this creature
      genome     : an array of chromosomes (represent parameters) whose genes
                   are bits, dominant=1 and recessive=0, written in a string   }

  procedure EliteCreatureFits (selectExperiment  : Integer;           // 1..dimE
                               var expControl    : TRMatrix;          // output
                               var expResponse   : TRMatrix;          // output
                               var modelControl  : TRMatrix;          // input
                               var modelResponse : TRMatrix);         // output
                               external 'GenAlg';
  { Retreive XY data that can be used to create graphs of model vs. experiment
    where
      selectExperiment  : choose an experiment for which the model is to be run
      expControl    : x data from the experiments for use in creating graphs
      expResponse   : y data from the experiments for use in creating graphs
      modelControl  : x data from model using the elite creature's parameters
      modelResponse : y data from model using the elite creature's parameters  }
      
  // --------------------------------------------------------------------------- 
  // ---------------------------------------------------------------------------

  // code specific to this application follows below
  
  // --------------------------------------------------------------------------- 
  // ---------------------------------------------------------------------------

  // Exported procedures
  
  procedure RunGeneticAlgorithm (reportName : String);
    var
      alienParam : TRVector;
      converged  : Boolean;
      expCtrl    : TRData;
      expResp    : TRData;
      fixedParam : TVectorFn;
      generation : Integer;
      model      : TModel;
      maxParam   : TRVector;
      minParam   : TRVector;
      names      : TSVector;
      sigFigs    : Integer;
      varyParam  : TBVector;
  begin
    // initialize fields
    sigFigs := 6;  // choose a fairly large number to get a larger population
    // assign field that are imported from gaData and gaModel
    alienParam := AlienParameters;
    expCtrl    := ExperimentalControlData;
    expResp    := ExperimentalResponseData;
    fixedParam := @MyFixedParameters;
    maxParam   := MaximumParameters;
    minParam   := MinimumParameters;
    model      := @MyModel;
    names      := NameParameters;
    varyParam  := VaryParameters;
    WriteLn;
    Write('Working on generation  1.');
    StartGeneticAlgorithm(model, expCtrl, expResp, 
                          varyParam, fixedParam, alienParam, minParam, maxParam, 
                          sigFigs, names, reportName);
    WriteLn('  done');
    generation := 1;
    converged  := False;
    repeat 
      Inc(generation);
      if generation < 10 then
        Write('Working on generation  ', generation)
      else
        Write('Working on generation ', generation);
      AdvanceToNextGeneration(converged);
      WriteLn('  done')
    until converged;
    // this final step writes out a report describing the findings from the GA
    StopGeneticAlgorithm
  end;

  procedure GetEliteData (var parameters : TRVector;
                          var genome     : TSVector);
    var
      fitness : Real;
  begin
    EliteCreatureData(fitness, parameters, genome);
  end;

  procedure GetModelData (selectExperiment : Integer;
                          var xExperiment  : TRMatrix;
                          var yExperiment  : TRMatrix;
                          var xModel       : TRMatrix;
                          var yModel       : TRMatrix);
  begin
    EliteCreatureFits(selectExperiment, xExperiment, yExperiment, 
                      xModel, yModel)
  end;
  
end.

