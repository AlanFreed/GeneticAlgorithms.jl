(* *****************************************************************************
  genAlg Author         - Alan D. Freed
  genAlg License        - GNU Lesser General Public License, vs 3 or later
  genAlg Copyright      - (c) Alan D. Freed 2014
  genAlg Pascal Version - 1.3.3
--------------------------------------------------------------------------------
  Use a genetic algorithm for the purpose of parameter estimation.
--------------------------------------------------------------------------------
  This application uses three external libraries, all written by the author:
     'Arrays' provides a collection of array type and procedures to manage them
     'rng'    provides a random number generator and statistical functions.
     'GenAlg' provides a genetic algorithm for use in parameter estimation.
--------------------------------------------------------------------------------
   This is one of three parts to the template.  Here the data are entered.
--------------------------------------------------------------------------------
   References
      Goldberg, D.E., Genetic Algorithms in Search, Optimization, and Machine
         Learning, Addison-Wesley, Boston, 1989.
      Goldberg, D.E., The Design of Innovation: Lessons learned from and for
         competent genetic algorithms.  In: Genetic algorithms and evolutionary
         computation, Vol. 7, Klewer, Boston, 2002.
      Johnson, N.L., "Systems of Frequency Curves Generated by Methods of
         Translation," Biometrika, Vol. 36 (1949), 149-176.       
***************************************************************************** *)

// global directives
{$MODE OBJFPC}      // allows objects, classes, interfaces, exception handling
{$H+}               // use ANSI strings
{$IFDEF UNIX}
  {$CALLING CDECL}  // uses the GCC calling convention  - for Unix libraries
  {$PIC ON}         // create Position Independent Code - for Unix libraries
{$ENDIF}

unit gaRelaxData;

interface

  uses
    {$IFDEF UNIX}{$IFDEF UseCThreads}
      cthreads,
    {$ENDIF}{$ENDIF}
    Classes, SysUtils, gaCore;
    
  // Exported constants/variables for the genetic algorithm for this application

  const
    dimE = 1;           // number of experiments
    dimR = 1;           // number of response variables over all experiments
    dimS = 27;          // number of fitted sample points over all experiments

  var
    dimNC : TIVector;   // number of control  variables per experiment
    dimNR : TIVector;   // number of response variables per experiment
    dimNS : TIVector;   // number of sampling points taken per experiment

  // ---------------------------------------------------------------------------
  
  // Exported procedures used by the solver
  
  // Data are staggered arrays of real matrices which index from
  //    [1..experiments][1..variables[experiment]][1..samples[experiment]]
  // where experiment lies within the interval of 1..experiments,
  // variables index from 1..experiments and
  // samples   index from 1..experiments.
    
  function ExperimentalControlData  : TRData;
  
  function ExperimentalResponseData : TRData;

implementation
    
  function ExperimentalControlData : TRData;
    var
      i    : Integer;
      data : TRData;
  begin
    // dimensioning the controls
    dimNC := NewIVector(dimE);
    // assign the number of control variables used in each experiment
    dimNC[1] := 1;
    // dimensioning the samplings
    if dimNS = nil then begin    // may be assigned in ExperimentalResponseData
      dimNS := NewIVector(dimE);
      // assign the number of samplings taken in each experiment
      dimNS[1] := dimS
    end;
    // dimensioning the return array of control variables
    data := NewRData(dimE, dimNC, dimNS);
    // assign the control (time) data to its data structure
    for i := 1 to 9 do
      data[1][1][i] := i;
    for i := 10 to 18 do 
      data[1][1][i] := 10.0 + (i - 10) * 10.0;
    for i := 19 to dimS do
      data[1][1][i] := 100.0 + (i - 19) * 25.0;
    // returning the data
    ExperimentalControlData := data
  end;

  function ExperimentalResponseData : TRData;
    var
      data : TRData;
  begin
    // dimensioning the responses
    dimNR := NewIVector(dimE);
    // assign the number of response variables used in each experiment
    dimNR[1] := dimR;
    // dimensioning the samplings
    if dimNS = nil then begin   // may be assigned in ExperimentalControlData
      dimNS := NewIVector(dimE);
      // assign the number of samplings taken in each experiment
      dimNS[1] := dimS
    end;
    // dimensioning the return array of response variables
    data := NewRData(dimE, dimNR, dimNS);
    // assigning the data to be returned
    data[1][1][1]  := 0.958111;
    data[1][1][2]  := 0.942603;
    data[1][1][3]  := 0.936295;
    data[1][1][4]  := 0.934543;
    data[1][1][5]  := 0.930502;
    data[1][1][6]  := 0.9303;
    data[1][1][7]  := 0.92802;
    data[1][1][8]  := 0.922957;
    data[1][1][9]  := 0.924434;
    data[1][1][10] := 0.919103;
    data[1][1][11] := 0.914073;
    data[1][1][12] := 0.906176;
    data[1][1][13] := 0.899717;
    data[1][1][14] := 0.89489;
    data[1][1][15] := 0.892362;
    data[1][1][16] := 0.886397;
    data[1][1][17] := 0.885421;
    data[1][1][18] := 0.887689;
    data[1][1][19] := 0.886335;
    data[1][1][20] := 0.874553;
    data[1][1][21] := 0.879646;
    data[1][1][22] := 0.876896;
    data[1][1][23] := 0.878161;
    data[1][1][24] := 0.87268;
    data[1][1][25] := 0.874975;
    data[1][1][26] := 0.875107;
    data[1][1][27] := 0.867039;
    ExperimentalResponseData := data
  end;
  
begin

  dimNC := nil;
  dimNR := nil;
  dimNS := nil;

  // initialize any additional global variables used in this unit   

end.

