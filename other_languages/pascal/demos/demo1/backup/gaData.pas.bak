(* *****************************************************************************
  genAlg Author         - Alan D. Freed
  genAlg License        - GNU Lesser General Public License, vs 3 or later
  genAlg Copyright      - (c) Alan D. Freed 2014
  genAlg Pascal Version - 1.2
--------------------------------------------------------------------------------
  Use a genetic algorithm for the purpose of parameter estimation.
--------------------------------------------------------------------------------
  This application uses three external libraries, all written by the author:
     'Arrays' provides a collection of array type and procedures to manage them
     'rng'    provides a random number generator and statistical functions.
     'GenAlg' provides a genetic algorithm for use in parameter estimation.
--------------------------------------------------------------------------------
   This is one of three parts to the template.  Here the data are entered.
--------------------------------------------------------------------------------
   References
      Goldberg, D.E., Genetic Algorithms in Search, Optimization, and Machine
         Learning, Addison-Wesley, Boston, 1989.
      Goldberg, D.E., The Design of Innovation: Lessons learned from and for
         competent genetic algorithms.  In: Genetic algorithms and evolutionary
         computation, Vol. 7, Klewer, Boston, 2002.
      Johnson, N.L., "Systems of Frequency Curves Generated by Methods of
         Translation," Biometrika, Vol. 36 (1949), 149-176.       
***************************************************************************** *)

// global directives
{$MODE OBJFPC}      // allows objects, classes, interfaces, exception handling
{$H+}               // use ANSI strings
{$IFDEF UNIX}
  {$CALLING CDECL}  // uses the GCC calling convention  - for Unix libraries
  {$PIC ON}         // create Position Independent Code - for Unix libraries
{$ENDIF}

unit gaData;

interface

  uses
    {$IFDEF UNIX}{$IFDEF UseCThreads}
      cthreads,
    {$ENDIF}{$ENDIF}
    Classes, SysUtils;
    
  // Array types defined in 'Arrays' and used by the 'GenAlg' library

  type
    TIVector = array of Integer;
    TRVector = array of Real;
    TRMatrix = array of TRVector;
    TData    = array of TRMatrix;
    
  // ---------------------------------------------------------------------------

  // Exported constants/variables for the genetic algorithm for this application

  const
    dimE = 1;           // number of experiments
    dimR = 1;           // number of response variables over all experiments
    dimS = 100;         // number of fitted sample points over all experiments

  var
    dimNC : TIVector;   // number of control  variables per experiment
    dimNR : TIVector;   // number of response variables per experiment
    dimNS : TIVector;   // number of sampling points taken per experiment

  // ---------------------------------------------------------------------------

  // Exported constants and variables that pertain to this application

  const
    xMin =  0.0;        // lower bound for the independent variable
    xMax = 10.0;        // upper bound for the independent variable

  var
    a0    : Real;       // y-intercept for data from linear regression
    a1    : Real;       // slope of data gotten from linear regression
    bb    : Real;       // assigned mean y-intercept of noisy experimental data
    mm    : Real;       // assigned mean    slope    of noisy experimental data
    xData : TRVector;   // independent variables in the experimental data set
    yData : TRVector;   //  dependent  variables in the experimental data set
  
  // Exported procedures used by the driver
  
  // Data are staggered arrays of real matrices which index from
  //    [1..experiments][1..variables[experiment]][1..samples[experiment]]
  // where experiment lies within the interval of 1..experiments,
  // variables index from 1..experiments and
  // samples   index from 1..experiments.
    
  function ExperimentalControlData  : TData;
  
  function ExperimentalResponseData : TData;

implementation
    
  // ---------------------------------------------------------------------------

  // Functions used to create and manage these array types
  
  function NewIVector (len : Integer) : TIVector; external 'Arrays';
  // Creates an integer vector indexing from 1 to len whose elements are all 0.

  function NewRVector (len : Integer) : TRVector; external 'Arrays';
  // Creates a real vector indexing from 1 to len whose elements are all 0.0.

  procedure DelRVector (var v : TRVector); external 'Arrays';
  // Deletes the information held by dynamic real vector v.

  function NewRMatrix (rows, columns : Integer) : TRMatrix; external 'Arrays';
  // Creates a real matrix indexing as [1..rows][1..columns]
  // whose elements are assigned values of 0.0.

  procedure DelRMatrix (var m : TRMatrix); external 'Arrays';
  // Deletes the information held by real matrix m.

  function NewData (experiments         : Integer;
                    var variablesPerExp : TIVector;
                    var samplesPerExp   : TIVector) : TData; external 'Arrays';
  // Creates a new real-valued data structure indexing as
  // [1..experiments][1..variablesPerExp[experiment]][1..samplesPerExp[experiment]
  // whose elements are all assigned values of 0.0.
  
  // --------------------------------------------------------------------------- ]

  // Function supplied by the 'rng' library

  function RandomNormal (mean, standardDeviation : Real) : Real; external 'rng';

  // ---------------------------------------------------------------------------

  function ExperimentalControlData : TData;
    var
      c, e, s : Integer;
      data    : TData;
  begin
    // dimensioning the controls
    dimNC := NewIVector(dimE);
    // assign the number of control variables used in each experiment
    dimNC[1] := 1;
    // dimensioning the samplings
    if dimNS = nil then begin    // may be assigned in ExperimentalResponseData
      dimNS := NewIVector(dimE);
      // assign the number of samplings taken in each experiment
      dimNS[1] := 100
    end;
    // dimensioning the return array of control variables
    data := NewData(dimE, dimNC, dimNS);
    // assigning the data to be returned
    for e := 1 to dimE do
      for c := 1 to dimNC[e] do
        for s := 1 to dimNS[e] do
          // assign the control data to its data structure
          data[e][c][s] := xData[s];
    // returning the data
    ExperimentalControlData := data
  end;

  function ExperimentalResponseData : TData;
    var
      e, r, s : Integer;
      data    : TData;
  begin
    // dimensioning the responses
    dimNR := NewIVector(dimE);
    // assign the number of response variables used in each experiment
    dimNR[1] := 1;
    // dimensioning the samplings
    if dimNS = nil then begin   // may be assigned in ExperimentalControlData
      dimNS := NewIVector(dimE);
      // assign the number of samplings taken in each experiment
      dimNS[1] := 100
    end;
    // dimensioning the return array of response variables
    data := NewData(dimE, dimNR, dimNS);
    // assigning the data to be returned
    for e := 1 to dimE do
      for r := 1 to dimNR[e] do
        for s := 1 to dimNS[e] do
          // assign the response data to its data structure
          data[e][r][s] := yData[s];
    // returning the data
    ExperimentalResponseData := data
  end;

  procedure CreateRandomDataSet;
    const
      dimP = 2;
    var
      detM, sd  : Real;
      p, q, s   : Integer;
      mInv      : TRMatrix;
      mMtx      : TRMatrix;
      rhs       : TRVector;
      summation : Real;
      y         : Real;
      zMtx      : TRMatrix;
  begin
    WriteLn;
    Write('What is the y-intercept of the line to be? ');
    ReadLn(bb);
    Write('What is the slope of the line to be?       ');
    ReadLn(mm);
    Write('What is the standard deviation for noise?  ');
    sd := 0.0;
    ReadLn(sd);
    // create dimS random data points along a central tendency of y = mm*x + bb
    for s := 1 to dimS do begin
      xData[s] := xMin + (s - 1) * (xMax - xMin) / (dimS - 1);
      y        := mm * xData[s] + bb;
      yData[s] := RandomNormal(y, sd)
    end;
    // perform a linear regression of these data
    zMtx := NewRMatrix(dimS, dimP);
    for s := 1 to dimS do begin
      zMtx[s][1] := 1.0;
      zMtx[s][2] := xData[s]
    end;
    mMtx := NewRMatrix(dimP, dimP);
    for p := 1 to dimP do
      for q := p to dimP do begin
        summation := 0.0;
        for s := 1 to dimS do
          summation := summation + zMtx[s][p] * zMtx[s][q];
        if p = q then
          mMtx[p][p] := summation
        else begin
          mMtx[p][q] := summation;
          mMtx[q][p] := summation
        end
      end;
    rhs := NewRVector(dimP);
    for p := 1 to dimP do begin
      summation := 0.0;
      for s := 1 to dimS do
        summation := summation + zMtx[s][p] * yData[s];
      rhs[p] := summation
    end;
    mInv := NewRMatrix(dimP, dimP);
    detM := mMtx[1][1] * mMtx[2][2] - mMtx[1][2] * mMtx[2][1];
    mInv[1][1] :=  mMtx[2][2] / detM;
    mInv[1][2] := -mMtx[1][2] / detM;
    mInv[2][1] :=  mInv[1][2];
    mInv[2][2] :=  mMtx[1][1] / detM;
    a0 := mInv[1][1] * rhs[1] + mInv[1][2] * rhs[2];
    a1 := mInv[2][1] * rhs[1] + mInv[2][2] * rhs[2];
    // clean up
    DelRMatrix(mInv);
    DelRMatrix(mMtx);
    DelRVector(rhs);
    DelRMatrix(zMtx)
  end;

begin

  dimNC := nil;
  dimNR := nil;
  dimNS := nil;

  // initialize any additional global variables used in this unit

  a0    := 0.0;
  a1    := 0.0;
  bb    := 0.0;
  mm    := 0.0;
  xData := NewRVector(dimS);
  yData := NewRVector(dimS);
  CreateRandomDataSet

end.

