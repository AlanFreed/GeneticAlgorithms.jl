(* *****************************************************************************
  genAlg Author         - Alan D. Freed
  genAlg License        - GNU Lesser General Public License, vs 3 or later
  genAlg Copyright      - (c) Alan D. Freed 2014
  genAlg Pascal Version - 1.3.3
--------------------------------------------------------------------------------
  Use a genetic algorithm for the purpose of parameter estimation.
--------------------------------------------------------------------------------
  This application uses three external libraries, all written by the author:
     'Arrays' provides a collection of array type and procedures to manage them
     'rng'    provides a random number generator and statistical functions.
     'GenAlg' provides a genetic algorithm for use in parameter estimation.
--------------------------------------------------------------------------------
   This is one of five parts to the template.  Here the data are entered.
--------------------------------------------------------------------------------
   References
      Goldberg, D.E., Genetic Algorithms in Search, Optimization, and Machine
         Learning, Addison-Wesley, Boston, 1989.
      Goldberg, D.E., The Design of Innovation: Lessons learned from and for
         competent genetic algorithms.  In: Genetic algorithms and evolutionary
         computation, Vol. 7, Klewer, Boston, 2002.
      Johnson, N.L., "Systems of Frequency Curves Generated by Methods of
         Translation," Biometrika, Vol. 36 (1949), 149-176.       
***************************************************************************** *)

// global directives
{$MODE OBJFPC}      // allows objects, classes, interfaces, exception handling
{$H+}               // use ANSI strings
{$IFDEF UNIX}
  {$CALLING CDECL}  // uses the GCC calling convention  - for Unix libraries
  {$PIC ON}         // create Position Independent Code - for Unix libraries
{$ENDIF}

unit gaData;

interface

  uses
    {$IFDEF UNIX}{$IFDEF UseCThreads}
      cthreads,
    {$ENDIF}{$ENDIF}
    Classes, SysUtils, gaCore;
    
  // Exported constants/variables for the genetic algorithm for this application

  const
    dimE = ?;           // number of experiments
    dimR = ?;           // number of response variables over all experiments
    dimS = ?;           // number of fitted sample points over all experiments

  var
    dimNC : TIVector;   // number of control  variables per experiment
    dimNR : TIVector;   // number of response variables per experiment
    dimNS : TIVector;   // number of sampling points taken per experiment

  // ---------------------------------------------------------------------------
  
  // Exported procedures used by the solver
  
  // Data are staggered arrays of real matrices which index from
  //    [1..experiments][1..variables[experiment]][1..samples[experiment]]
  // where experiment lies within the interval of 1..experiments,
  // variables index from 1..experiments and
  // samples   index from 1..experiments.
    
  function ExperimentalControlData  : TRData;
  
  function ExperimentalResponseData : TRData;

implementation
    
  function ExperimentalControlData : TRData;
    var
      c, e, s : Integer;
      data    : TRData;
  begin
    // dimensioning the controls
    dimNC := NewIVector(dimE);
    // assign the number of control variables used in each experiment
    dimNC[1] := ?;
    ...
    // dimensioning the samplings
    if dimNS = nil then begin    // may be assigned in ExperimentalResponseData
      dimNS := NewIVector(dimE);
      // assign the number of samplings taken in each experiment
      dimNS[1] := ?;
      ...
    end;
    // dimensioning the return array of control variables
    data := NewRData(dimE, dimNC, dimNS);
    // assigning the data to be returned
    for e := 1 to dimE do
      for c := 1 to dimNC[e] do
        for s := 1 to dimNS[e] do begin
          // assign the control data to its data structure
          data[e][c][s] := ?;
          ...
        end;
    // returning the data
    ExperimentalControlData := data
  end;

  function ExperimentalResponseData : TRData;
    var
      e, r, s : Integer;
      data    : TRData;
  begin
    // dimensioning the responses
    dimNR := NewIVector(dimE);
    // assign the number of response variables used in each experiment
    dimNR[1] := ?;
    ...
    // dimensioning the samplings
    if dimNS = nil then begin   // may be assigned in ExperimentalControlData
      dimNS := NewIVector(dimE);
      // assign the number of samplings taken in each experiment
      dimNS[1] := ?;
      ...
    end;
    // dimensioning the return array of response variables
    data := NewRData(dimE, dimNR, dimNS);
    // assigning the data to be returned
    for e := 1 to dimE do
      for r := 1 to dimNR[e] do
        for s := 1 to dimNS[e] do begin
          // assign the response data to its data structure
          data[e][r][s] := ?;
          ...
        end;
    // returning the data
    ExperimentalResponseData := data
  end;
  
begin

  dimNC := nil;
  dimNR := nil;
  dimNS := nil;

  // initialize any additional global variables used in this unit   

end.

