(* *****************************************************************************
  genAlg Author         - Alan D. Freed
  genAlg License        - GNU Lesser General Public License, vs 3 or later
  genAlg Copyright      - (c) Alan D. Freed 2014
  genAlg Pascal Version - 1.3
--------------------------------------------------------------------------------
  Use a genetic algorithm for the purpose of parameter estimation.
--------------------------------------------------------------------------------
  This application uses three external libraries, all written by the author:
     'Arrays' provides a collection of array type and procedures to manage them
     'rng'    provides a random number generator and statistical functions.
     'GenAlg' provides a genetic algorithm for use in parameter estimation.
--------------------------------------------------------------------------------
   This is one of three parts to the template.  Here your model is defined.
--------------------------------------------------------------------------------
   References
      Goldberg, D.E., Genetic Algorithms in Search, Optimization, and Machine
         Learning, Addison-Wesley, Boston, 1989.
      Goldberg, D.E., The Design of Innovation: Lessons learned from and for
         competent genetic algorithms.  In: Genetic algorithms and evolutionary
         computation, Vol. 7, Klewer, Boston, 2002.
      Johnson, N.L., "Systems of Frequency Curves Generated by Methods of
         Translation," Biometrika, Vol. 36 (1949), 149-176.       
***************************************************************************** *)

// global directives
{$MODE OBJFPC}      // allows objects, classes, interfaces, exception handling
{$H+}               // use ANSI strings
{$IFDEF UNIX}
  {$CALLING CDECL}  // uses the GCC calling convention  - for Unix libraries
  {$PIC ON}         // create Position Independent Code - for Unix libraries
{$ENDIF}

unit gaModel;

interface

  uses
    {$IFDEF UNIX}{$IFDEF UseCThreads}
      cthreads,
    {$ENDIF}{$ENDIF}
    Classes, SysUtils, gaCore, gaData;
    
  // Exported constants for the genetic algorithm pertinent to this application

  const
    dimP  = ?;          // number of parameters, both fixed and varied
    dimPV = ?;          // number of parameters that are allowed to vary

  // A model is implemented for parameter estimation via an instance of type

  type
    TModel = procedure (experiment           : Integer;      // input
                        var modelParameters  : TRVector;     // input
                        var controlData      : TRMatrix;     // input
                        var responseData     : TRMatrix);    // output
{ where
    experiment       : used to determine which experiment to get response data
                       an interger between 1 and dimE
    modelParameters  : all model parameters (both fixed and adjustable)
                       indices range over [1..dimP]
    controlData      : a sequence of experimentally controlled values
                       [controlVariable][valueAtASamplingInstant]
                       indices range over [1..dimNC[e]][1..dimNS[e]]
    responseData     : predicted responses for these controls & parameters
                       [responseVariable][valueAtASamplingInstant]
                       indices range over [1..dimNR[e]][1..dimNS[e]]           }
                       
  // Exported procedures and functions used by the driver
                       
  procedure MyModel (experiment           : Integer;      // input
                     var modelParameters  : TRVector;     // input
                     var controlData      : TRMatrix;     // input
                     var responseData     : TRMatrix);    // output
  { an instance of type TModel }

  // Associated functions that are sent to the genetic algorithm
  
  function VaryParameters : TBVector;
  { specify which parameters are to be varied (TRUE) and which are not (FALSE) }
  
  function NameParameters : TSVector;
  { assign names to all of the parameters, varied and fixed, for the report }
  
  // The remaining procedure provide information for the varied parameters only
  
  function FixedParameters : TRVector;  
  { assign values to the fixed parameters - if all vary return nil }
    
  function AlienParameters : TRVector;  
  { best guess at what the varied parameters might be }
    
  function MaximumParameters : TRVector;  
  { upper boundary of the search domain for all of the varied parameters }
    
  function MinimumParameters : TRVector;  
  { lower boundary of the search domain for all of the varied parameters }
  
implementation

  // Create the model to be used to fit the data against
  
  procedure MyModel (experiment           : Integer;      // input
                     var modelParameters  : TRVector;     // input
                     var controlData      : TRMatrix;     // input
                     var responseData     : TRMatrix);    // output
  begin
    ...
  end;
  
  // user-defined procedures required in every GenAlg application
  
  // the length of VaryParameters is for all parameter, both varied and fixed

  function VaryParameters : TBVector;
    var
      vary : TBVector;
  begin
    vary := NewBVector(dimP);
    vary[1] := ?;
    ...
    VaryParameters := vary
  end;
  function NameParameters : TSVector;
    var
      names : TSVector;
  begin
    names := NewSVector(dimP);
    // assign names to both the fixed and varied parameters
    names[1] := ?;
    ...
    NameParameters := names
  end;
  
  // all remaining functions return vectors of the varied parameter length

  function FixedParameters : TRVector;
    var
      fixed : TRVector;
  begin
    if dimP = dimPV then
      fixed := nil
    else begin
      // these sequence according to VaryParameters, i.e., the first occurance 
      // where VaryParameters[i] is FALSE gets assigned to FixedParameters[1]
      fixed := NewRVector(dimP-dimPV);
      fixed[1] := ?;
      ...
    end;
    FixedParameters := fixed
  end;

  function AlienParameters : TRVector;
    var
      alien : TRVector;
  begin
    // this is a guess at what one expects the varied parameters should be
    alien := NewRVector(dimPV);
    alien[1] := ?;
    ...
    AlienParameters := alien
  end;

  function MaximumParameters : TRVector;
    var
      maxP : TRVector;
  begin
    // the greatest (or most positive) parameter values to be considered
    maxP := NewRVector(dimPV);
    maxP[1] := ?;
    ...
    MaximumParameters := maxP
  end;

  function MinimumParameters : TRVector;
    var
      minP : TRVector;
  begin
    // the smallest (or most negative) parameter values to be considered
    minP := NewRVector(dimPV);
    minP[1] := ?;
    ...
    MinimumParameters := minP
  end;
    
begin

end.
